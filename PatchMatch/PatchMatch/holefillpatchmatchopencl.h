#ifndef IEC_HOLEFILLPATCHMATCHOPENCL_H
#define IEC_HOLEFILLPATCHMATCHOPENCL_H

#include <OpenCL/openclgpuhost.h>

#include <Core/image/imagetypes.h>
#include <Core/utility/twodarray.h>
#include <Core/utility/vector3.h>

#include <boost/noncopyable.hpp>

#include <array>
#include <memory>
#include <queue>

namespace patchMatch {

/// Performs the hole-filling PatchMatch problem using OpenCL.
class HoleFillPatchMatchOpenCL : public openCL::OpenCLGPUHost, private boost::noncopyable
{
public:
    HoleFillPatchMatchOpenCL( const openCL::Device& device );

    enum Step
    {
        Blend,
        Search,
        Propagate,
        NextPyramid
    };

    void init(
        const core::ImageRGB& targetOriginalSize,
        const core::ImageBinary& targetMask, 
        int numPyramidLevels, 
        int patchWidth );

    void planStep(Step step);

    /// The most recently planned step must be 'Blend'; else throw exception.
    void executeSteps(core::ImageRGB& blendResult);
private:
    void cleanupMemObjects();
    bool stepsValidForExecution();

    void enqueueSetupNextPyramidLevel();
    void enqueueSetupAnchorWeights(); 
    void enqueueSetupFirstNNF(); 
    void enqueueSetupNextNNF(
        const core::IntCoord& prevTargetDims, 
        const core::IntCoord& prevSourceDims ); 
    void enqueueInitialHoleFill();
    void enqueueBlend();
    void enqueueSearch();
    void enqueuePropagate();

    /// These are the pending operations which will be performed as soon as the user
    /// invokes executeSteps().
    std::queue< Step > _steps;

    int _numPyramidLevels;
    int _currentPyramidLevel;
    int _patchWidth;
    core::IntCoord _targetPyramidDims;
    core::IntCoord _sourcePyramidDims;
    core::IntCoord _targetOriginalDims;
    core::IntCoord _sourceOriginalDims;

    //OpenCL items:  Some of these are C++ wrappers (such as cl::Program _program).
    //Some are pointers to C++ wrappers.  The latter indicate components that
    //need to be destroyed and recreated during the lifetime of this class object.

    //programs and kernels
    cl::Program _holeFillProgram;
    cl::Kernel _blendKernel;
    cl::Kernel _sourceMaskFromTargetMaskKernel;
    cl::Kernel _anchorWeightsFromInternalDistMapKernel;
    cl::Kernel _nnfInitialFillKernel;
    cl::Kernel _nnfUpsampleCoordsKernel;
    cl::Kernel _nnfCostsKernel;
    cl::Kernel _searchKernel;
    cl::Kernel _blackOutMaskedAreaKernel;
    cl::Kernel _initialHoleFillKernel;
    cl::Kernel _propagateKernel;
    cl::Program _utilityProgram;
    cl::Kernel _downsampleRGBImageKernel;
    cl::Kernel _downsampleBooleanImageKernel;
    cl::Kernel _internalDistanceMapInitKernel;
    cl::Kernel _distanceMapStepKernel;

    // OpenCL images (note that original size images are non-pointers, which mean
    // they do not need to be recreated during the lifetime of this class object.
    std::unique_ptr< cl::Image2D > _targetOriginalSize;
    std::unique_ptr< cl::Image2D > _sourceOriginalSize;
    std::unique_ptr< cl::Buffer > _targetMaskOriginalSize;
    std::unique_ptr< cl::Image2D > _targetPyramidSize;
    std::unique_ptr< cl::Buffer > _targetMaskPyramidSize;
    std::unique_ptr< cl::Image2D > _sourcePyramidSize;
    std::unique_ptr< cl::Buffer > _sourceMaskPyramidSize;

    //Anchor weights is double-buffered because we use jumpflood (an inherently
    //double-buffered algorithm) to initialize it.  Jumpflood is used to create
    //the distance map
    std::array< std::unique_ptr< cl::Buffer >, 2 > _anchorWeights;
    bool _anchorWeightsReadIndex; //treated as index into _anchorWeights

    //The nnf, which is made of two cl::Buffers, must also
    //be double-buffered.
    std::array< std::unique_ptr< cl::Buffer >, 2 > _nnfCoords;
    std::array< std::unique_ptr< cl::Buffer >, 2 > _nnfCosts;
    bool _nnfReadIndex;  //treated as index into _nnfCoords and _nnfCosts

    //A set of seeds enabling us to have a random sequence for every target pixel.  This is initialized
    //with seeds generated by rand() on the CPU side, but that is done only at initialization, NOT
    //at each pyramid level.
    std::unique_ptr< cl::Buffer > _randomBuffer;
};

} // patchMatch

#endif // #include

