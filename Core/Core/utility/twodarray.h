#ifndef CORE_TWODARRAY_H
#define CORE_TWODARRAY_H

#include <Core/exceptions/runtimeerror.h>
#include <Core/utility/intcoord.h>
#include <Core/utility/linesegment.h>

#include <boost/numeric/conversion/cast.hpp>

#include <memory>
#include <functional>
#include <vector>

namespace core {

template< typename T >
class TwoDArray
{
public:

    using Type = TwoDArray< T >;

    explicit TwoDArray(
        int width = 1, 
        int height = 1, 
        T initialVal = T() )
    {
        recreate(width,height,initialVal);
    }

    explicit TwoDArray( TwoDArray&& other )
    {
        *this = std::move( other );
    }

    TwoDArray& operator = ( TwoDArray&& other )
    {
        _width = other.width();
        _height = other.height();
        _array = std::move( other._array );
        other._array = nullptr;
        other.recreate( 1, 1 );
        return *this;
    }

    int width() const { return _width; }
    int height() const { return _height; }
    IntCoord size() const { return IntCoord(_width,_height); }
    bool singleValue() const { return _width == 1 && _height == 1; }

    static void clone(const TwoDArray<T>& source, TwoDArray<T>& dest);
    static void checkerboard(TwoDArray<T>& store, int width, int height, const T& colorA, const T& colorB, int cellWidth);
    static void stripes(TwoDArray<T>& store, int width, int height, int stripeWidth, int gapWidth, const T& colorStripe, const T& colorGap);

    /// The inputs must be in [0,width] and [0,height], respectively. Treat a cell's value as being
    /// defined at its center.
    T interpolate( double x, double y ) const;
    T interpolate( const Vector2& coord ) const;
    /// The inputs must all be created by a call to interpolateSetup().
    T interpolate(
        double fX,
        double fY,
        const IntCoord& tl,
        const IntCoord& tR,
        const IntCoord& bR,
        const IntCoord& bL ) const;
    /// Given 'x' and 'y' in [0,width] and [0,height], fill the rest of the parameters with the inputs
    /// to the low-level interpolate() overload.
    void interpolateSetup(
        double x,
        double y,
        double& fX,
        double& fY,
        IntCoord& tL,
        IntCoord& tR,
        IntCoord& bR,
        IntCoord& bL ) const;

    /// Return whether 'pos' is inside the box from (0,0) to (width,height).
    bool contains( const Vector2 pos ) const;

    T get(int x, int y) const
    {
#ifdef _DEBUG
        if(!isValidCoord(x,y))
        {
            THROW_RUNTIME( "Illegal get attempted!" );
        }
#endif
        return _array[y*_width+x];
    }

    T get(const IntCoord& coord) const
    {
        return get(coord.x(),coord.y());
    }

    T get(int xy) const
    {
#ifdef _DEBUG
        int y = xy/width();
        int x = xy-y*width();
        if(!isValidCoord(x,y))
        {
            THROW_RUNTIME( "Illegal get attempted" );
        }
#endif
        return _array[xy];
    }

    T& getRef( const IntCoord& coord )
    {
        return const_cast< T& >( const_cast< const Type* >( this )->getRef( coord.x(), coord.y() ) );
    }

    T& getRef( int x, int y )
    {
        return const_cast< T& >( const_cast< const Type* >( this )->getRef( x, y ) );
    }

    T& getRef( int xy )
    {
        return const_cast< T& >( const_cast< const Type* >( this )->getRef( xy ) );
    }

    const T& getRef( const IntCoord& coord ) const
    {
        return getRef( coord.x(), coord.y() );
    }

    const T& getRef( int x, int y ) const
    {
        return getRef( x + _width * y );
    }

    const T& getRef( int xy ) const
    {
        return _array[ xy ];
    }

    bool isValidCoord(int x, int y) const
    {
        return x>=0 && y>=0 && x<=_width-1 && y<=_height-1;
    }

    bool isValidCoord(const IntCoord& coord) const
    {
        return isValidCoord(coord.x(), coord.y());
    }


    void set(int x, int y, T val)
    {
#ifdef _DEBUG
        if(!isValidCoord(x,y))
        {
            THROW_RUNTIME( "Illegal set attempted!" );
        }
#endif
        _array[y*_width+x] = val;
    }


    void set( const IntCoord& coord, T val )
    {
        set(coord.x(),coord.y(),val);
    }  

    void set( T val )
    {
        const int w = width(), h = height();
        for( int x = 0; x < w; x++ ) {
            for( int y = 0; y < h; y++ ) {
                set( x, y, val );
            }
        }
    }

    /// Set every cell to a value generated by a functor that takes in a coordinate as input.
    void set( std::function< T( int x, int y ) > functor )
    {
        const int w = width(), h = height();
        for( int x = 0; x < w; x++ ) {
            for( int y = 0; y < h; y++ ) {
                set( x, y, functor( x, y ) );
            }
        }
    }

    void forEveryPos( std::function< void( const T& ) > functor ) const
    {
        const int w = width();
        const int h = height();
        for( int x = 0; x < w; x++ ) {
            for( int y = 0; y < h; y++ ) {
                functor( getRef( x, y ) );
            }
        }
    }

    void forEveryPos( std::function< void( T& ) > functor )
    {
        const int w = width();
        const int h = height();
        for( int x = 0; x < w; x++ ) {
            for( int y = 0; y < h; y++ ) {
                functor( getRef( x, y ) );
            }
        }
    }

    void recreate(const IntCoord& size, T initialVal=T())
    {
        recreate(size.x(),size.y(),initialVal);
    }

    void recreate(int width, int height, T initialVal=T())
    {
        if (width < 1 || height < 1) {
            THROW_RUNTIME("Illegal dimensions");
        }
        _width=width;
        _height=height;

        const size_t numEntries = width * height;
        _array = std::make_unique< T[] >( numEntries );
        for( size_t i = 0; i < numEntries; i++ )
        {
            _array[ i ] = initialVal;
        }
    }

    const T* array() const
    {
        return _array.get();
    }

private:
    TwoDArray(const TwoDArray& other); 
    TwoDArray& operator=(const TwoDArray& other); 

    int _width;
    int _height;

    /// row-major 
    std::unique_ptr< T[] > _array;
};

template<typename T>
void TwoDArray<T>::checkerboard(TwoDArray<T>& store, int width, int height, const T& colorA, const T& colorB, int cellWidth)
{
    if(store.width()!=width || store.height()!=height)
    {
        store.recreate(width,height);
    }
    for(int x=0; x<width; x++)
    {
        for(int y=0; y<height; y++)
        {
            store.set(x,y, (x/cellWidth)%2==(y/cellWidth)%2  ? colorA : colorB);
        }
    }
}

template<typename T>
void TwoDArray<T>::stripes(TwoDArray<T>& store, int width, int height, int stripeWidth, int gapWidth, const T& colorStripe, const T& colorGap)
{
    if(store.width()!=width || store.height()!=height)
    {
        store.recreate(width,height);
    }

    for(int x=0; x<width; x++)
    {
        //an element is a stripe + its next gap
        int elementIdx =x/(stripeWidth+gapWidth);
        bool isStripe = x-elementIdx*(stripeWidth+gapWidth)<stripeWidth;

        for(int y=0;y<height; y++)
        {
            store.set(x,y,isStripe ? colorStripe : colorGap);
        }
    }
}

template<typename T>
void TwoDArray<T>::clone(const TwoDArray<T> &source, TwoDArray<T> &dest)
{
    if(dest.width()!=source.width() || dest.height()!=source.height())
    {
        dest.recreate(source.width(), source.height());
    }
    for(int x=0; x<source.width(); x++)
    {
        for(int y=0; y<source.height(); y++)
        {
            dest.set(x,y,source.get(x,y));
        }
    }
}

template<typename T>
T TwoDArray<T>::interpolate( const Vector2& coord ) const
{
    return interpolate(coord.x(),coord.y());
}

template< typename T >
void TwoDArray< T >::interpolateSetup(
    double x,
    double y,
    double &fX,
    double &fY,
    IntCoord &tL,
    IntCoord &tR,
    IntCoord &bR,
    IntCoord &bL ) const
{
    if( x < 0 ) {
        x = 0;
    }
    if( y < 0 ) {
        y = 0;
    }

    if( x >= _width ) {
        x = _width;
    }
    if( y >= _height ) {
        y = _height;
    }

    int xLeft = 0, xRight = 0, yTop = 0, yBottom = 0;
    if( x > 0.5 ) {
        xLeft = static_cast< int >( x - 0.5 );
        xRight = xLeft < _width - 1 ? xLeft + 1 : xLeft;
    }
    if( y > 0.5 ) {
        yTop = static_cast< int >( y - 0.5 );
        yBottom = yTop < _height - 1 ? yTop + 1 : yTop;
    }

    tL = { xLeft, yTop };
    tR = { xRight, yTop };
    bR = { xRight, yBottom };
    bL = { xLeft, yBottom };
    fX = x - ( static_cast< double >( xLeft ) + 0.5 );
    fY = y - ( static_cast< double >( yTop ) + 0.5 );
}

template< typename T >
T TwoDArray<T>::interpolate( double x, double y ) const
{
    double fX, fY;
    IntCoord tL, tR, bR, bL;
    interpolateSetup( x, y, fX, fY, tL, tR, bR, bL );
    return interpolate( fX, fY, tL, tR, bR, bL );
}

template< typename T >
T TwoDArray< T >::interpolate(
    double fX,
    double fY,
    const IntCoord& tL,
    const IntCoord& tR,
    const IntCoord& bR,
    const IntCoord& bL ) const
{
    const T topLeft = get( tL );
    const T bottomRight = get( bR );
    const T topRight = get( tR );
    const T bottomLeft = get( bL );

    const T interp1 = static_cast< T >( topLeft + ( topRight - topLeft ) * fX );
    const T interp2 = static_cast< T >( bottomLeft + ( bottomRight - bottomLeft ) * fX );
    return static_cast< T >( interp1 + ( interp2 - interp1 ) * fY );
}

template< typename T >
bool TwoDArray< T >::contains( const Vector2 pos ) const
{
    const auto x = pos.x();
    const auto y = pos.y();

    return x >= 0
        && x <= _width
        && y >= 0
        && y <= _height;
}

} // core

#endif // #include guard
